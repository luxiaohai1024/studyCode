<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>算法测试</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            list-style: none;
            text-decoration: none;
        }

        html,
        body {
            width: 100%;
            height: 100%;
        }

        ul{
            width: 100%;
        }

        li {
            padding: 10px;
            float: left;
        }
        h1,
        div {
            float: left;
            width: 100%;
            height: 50px;
        }

        span {
            display: block;
            width: 100%;
            height: 200px;
            overflow: scroll;
        }
    </style>
</head>
<body>
    <h1>生成随机数组</h1>
    <span>
        <ul id="natureArr"></ul>
    </span>
    
    <h1>选择排序后的数组</h1>
    <span>
        <ul id="SelectionSortArr"></ul>
    </span>
    
    <h1>所用的时间</h1>
    <div id="SelectionSortTime"></div>
    
    <h1>插入排序后的数组</h1>
    <span>
        <ul id="insertionSortArr"></ul>
    </span>
    
    <h1>所用的时间</h1>
    <div id="insertionSortTime"></div>


    <script src="./SortTestHelper/UtilMethod.js"></script>
    <script src="./scripts/jquery.js"></script>
    <script>
        var n = 10000;
        var natureArr = MyUtilMethod.generateRandomArray(n, 0, n);
        MyUtilMethod.printArray('natureArr', natureArr)
    </script>

    <!-- 排序算法 -->
    <!-- 选择排序 -->
    <!-- 
     O(n^2)的排序算法
    作用：

    1. 基础。
    2. 编码简单，易于实现，是一些简单情景的首选。
    3. 在一些特殊情况下，简单的排序算法更有效。
    4. 简单的排序算法思想衍生出复杂的排序算法。
    5. 作为子过程，改进更复杂的排序算法。

   
    选择排序 （Selection Sort）

    1. 遍历数组，找到最小（大）的数，放在第一个位置。
    2. 从第二个位置开始遍历数组，找到最小（大）的数，放在第二个位置。
    3. 以此类推，直到排序完成。 -->
    <script src="./SelectionSort.js"></script>
    <script>
        var SelectionSortNewArr = SelectionSort(natureArr);
        MyUtilMethod.printArray("SelectionSortArr",SelectionSortNewArr);
        MyUtilMethod.testSort("Selection Sort", SelectionSort, natureArr, "SelectionSortTime")
    </script>

    <!-- 插入排序 （Insertion Sort）
    打牌的时候插入牌类似这种算法。

    以8、6、2、3、1、5、7、4为例

    1. 第一个数不动（8、6、2、3、1、5、7、4）
    2. 第二个数如果比第一个数小，和第一个数交换位置（6、8、2、3、1、5、7、4）
    3. 第三个数如果比第二个数小，和第二个数交换位置（6、2、8、3、1、5、7、4）
    4. 之前第三的数在第二的位置，将其与第一个数比较，如果比第一个数小，和第一个数交换位置（2、6、8、3、1、5、7、4）
    5. 以此类推（2、3、6、8、1、5、7、4） -->

    <script src="./insertionSort.js"></script>
    <script>
        console.log(natureArr);
        var insertionSortNewArr = insertionSort(natureArr);
        MyUtilMethod.printArray("insertionSortArr",insertionSortNewArr);
        MyUtilMethod.testSort("insertion Sort", insertionSort, natureArr, "insertionSortTime")
    </script>
</body>
</html>